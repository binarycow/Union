
## C# Source Generator

1. Add a reference to the `Union.SourceGenerator` package
2. Create a `struct` and apply the `GenerateUnion` attribute to it.
3. Add a `field` for each value you'd like to store in the type.

If you'd like some "basic types" generated, see the [Basic Types](#basic-types) section


## Requirements

1. Struct requirements
    1. Struct must be `partial`
    2. Struct must be `readonly`
    3. Struct must have the `GenerateUnion` attribute applied
2. Field requirements
   1. Fields must be `readonly`
   2. Field names _should_ be in the format `_Name` or `name`
   3. There can only be one field for every type.  
(Exception: A [user defined index field](#user-defined-index-field)) does not apply here)

## Generated members

By default, the following members are generated.  For items marked as 'Optional', you can turn off generation of these members.
See the [options](#controlling-generated-members) section to control what is generated

- 1x constructor for each field (Mandatory)
- Equals/GetHashCode (Mandatory for `struct`)
- "As" methods (Optional) - to convert to one of the given types.  **Important:** This method will throw an 
exception if the value is not the correct type.
- "Is" methods (Optional) - to check if the value is one of the given types.  This will **not** throw 
an exception, even if the value is not the correct type.
- `Value` property (Optional) - exposes the value as `object`
- `ToString` (Optional)
- `Switch` (Optional) methods - Execute an `Action` or `Func` on the value.  Each overload accepts a
delegate for each field type.
- `From` (Optional) methods - static factory methods
- `implicit` conversion operators (Optional) - Implicitly convert native types to the union type.


## Options

### Controlling generated members

You can control which members are generated by passing a `UnionOptions` value to the constructor
of the `GenerateUnion` attribute.  For example, in the below snippet, implicit conversion operators
and the `Switch` methods are generated, but not the static factory methods, `ToString`, etc.

```csharp
[GenerateUnion(UnionOptions.Conversions | UnionOptions.Switch)]
public readonly partial struct FileResult
{
    private readonly None none;
    private readonly Error<string> errorMessage;
    private readonly string? result;
}
```

### User-defined index field

The source generator will generate an index field, which is named `index` by default.  This means that
by default, you cannot use a field name of `index` for your user-defined fields. If you use this 
attribute, you can use any field name you'd like.

Additionally,  You may get a compiler warning [CS0282](https://docs.microsoft.com/en-us/dotnet/csharp/misc/cs0282).  
This is because the source generator, by default, adds a field (named `index`) to the generated file.  
If you don't want to suppress this warning, you can explicitly define an index field.  

```csharp
[GenerateUnion]
public readonly partial struct Result<T>
{
    [UnionIndexAttribute]
    private readonly int index;

    private readonly T success;
    private readonly Error<string> errorMessage;
}
```

### Basic Types

To generate the basic types, apply the `BasicTypes` attribute to your **assembly**,
specifying the accessibility (`public`/`internal`), as well as which types to generate.

For example, the below will generate the `Error` and `None` types, and make them `public`.

```csharp
[assembly: BasicTypes(Accessibility.Public, BasicTypes.Error | BasicTypes.None)]
```

## Examples

### Basic example

```csharp
[GenerateUnion]
public readonly partial struct FileResult
{
    private readonly None none;
    private readonly Error<string> errorMessage;
    private readonly string? result;
}

internal static class Program
{
    private static void Main()
    {
        ReadFileText("C:\\Path\\to\\file.txt").Switch(
            _ => Console.WriteLine($"File doesn't exist."),
            error => Console.WriteLine($"Error: {error.Value}"),
            contents => Console.WriteLine($"File contents: {contents}")
        );
    }
    private static FileResult ReadFileText(string path)
    {
        try
        {
            if (File.Exists(path) == false)
                return new None();
            return File.ReadAllText(path);
        }
        catch (Exception e)
        {
            return new Error<string>(e.Message);
        }
    }
}
```